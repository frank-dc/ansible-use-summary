package org.frank.basic.bitwise;
/*
    位运算符：需要先把数据转换成二进制，再进行运算。
        位 & 运算符：有 0 则 0
        位 | 运算符：有 1 则 1
        位 ^ 运算符：相同则 0，不同则 1
        位 ~ 运算符：取反

 */

public class OperatorDemo {
    public static void main(String[] args) {
        System.out.println(3 & 5);  // 1
        System.out.println(3 | 5);  // 7
        System.out.println(3 ^ 5);  // 6
        System.out.println(~3);     // -4
        System.out.println(~5);     // -6
    }
}

/*
    3 的二进制：00000000 00000000 00000000 00000011
    5 的二进制：00000000 00000000 00000000 00000101

    A) 3 & 5 = 1
      00000000 00000000 00000000 00000011
     &00000000 00000000 00000000 00000101
     ------------------------------------
      00000000 00000000 00000000 00000001

    B) 3 | 5 = 7
      00000000 00000000 00000000 00000011
     |00000000 00000000 00000000 00000101
     ------------------------------------
      00000000 00000000 00000000 00000111

    C) 3 ^ 5 = 6
      00000000 00000000 00000000 00000011
     ^00000000 00000000 00000000 00000101
     ------------------------------------
      00000000 00000000 00000000 00000110

    D) ~3
     ~00000000 00000000 00000000 00000011
     ------------------------------------
      11111111 11111111 11111111 11111100   现代计算机中，通常用补码表示有符号整数。
  反码 11111111 11111111 11111111 11111011
  原码 10000000 00000000 00000000 00000100

  补码 - 1 = 反码
  !反码 = 原码（符号位不变）

    E) ~5
     ~00000000 00000000 00000000 00000101
     ------------------------------------
      11111111 11111111 11111111 11111010
  反码 11111111 11111111 11111111 11111001
  原码 10000000 00000000 00000000 00000110

 */
